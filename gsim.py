#!/usr/bin/python
"""
Basic implementation of the Gillespie algorithm.
"""

import numpy as np
import matplotlib.pyplot as plt

class Species(object):
    """A chemical species. Has the inherent properties name and count."""
    def __init__(self, name, count):
        self.count = count
        self.name = name
    
    def produce(self):
        self.count += 1
        
    def destroy(self):
        self.count -= 1

class Reaction(object):
    """A Reaction used in Gillespie simulation.
    
    A general class which defines the required outputs for a reaction
    (propensity); inputs include name of the reaction (str), input (list of
    species objects), output (list of species objects), rate (float), and
    potentially a description of the reaction (str).
    The base class has no perform function! You must explicitly define the
    reaction for each new reaction (for now?)
    """
    def __init__(self, name, ip, op, rate):
        self.name = name
        self.rate = rate
        self.ip = ip
        self.op = op
        
    def prop(self):
        alpha = self.rate
        for i in self.ip:
            alpha *= i.count
        return alpha
        
#    def perform(self):
#        pass
        
class ConstInduction(Reaction):
    """Specific Reaction instance with a rate independent of species concentration.

    0 -> A
    """
    def prop(self):
        return self.rate
        
    def perform(self):
        self.op[0].produce()
        
class UniDeg(Reaction):
    """Specific Reaction instance of degredation.
    
    A -> 0
    The propensity is dependent on the concentration of the species being degraded.
    """
    def perform(self):
        self.ip[0].destroy()
        
        
class Network(object):
    """Holds a reaction network which can be acted on during the Gillespie
    loop.
    
    Initializing a network requires a list of Species (with
    associated inital counts) and a list of possible Reactions (with associated
    rates, inputs, outputs, etc.)
    Make sure to import numpy as np
    """
    def __init__(self, sp_list, rxn_list):
        self.species = sp_list
        self.reactions = rxn_list
        
    def simulate(self, t_start, t_end, filename):
        """Implementation of the Gillespie SSA.
        
        No check on runtime. Make sure to double check rate/times so that
        simulation doesn't get out of control. filename should be a string.
        """
        assert t_start < t_end
        t = t_start
        n_steps = 0
        time = [[t]]
        data = [[i.count for i in self.species]]
        while t <= t_end:
            r1, r2 = np.random.uniform(), np.random.uniform()
            alpha_vec = [i.prop() for i in self.reactions]
            alpha = np.sum(alpha_vec)
            try:
                tau = 1./alpha*np.log(1./r1)
            except ZeroDivisionError:
                print "Propensity equal to zero at step = %d, time = %d;\
                Simulation terminated." % (n_steps, t)
                break

            t = t + tau
            n_steps += 1
            #update species; there is definitely a better/faster way to do this
            #also find a way to ensure that a reaction happens at every time step
            #lead -> no two rows in the final array should be the same except time
            z = 0
            for i in range(len(alpha_vec)):
                z += alpha_vec[i]
                if float(z)/alpha == 1.0:
                    self.reactions[i].perform()
                    #print self.reactions[i].name
                    break
                elif r2 < float(z)/alpha:
                    self.reactions[i].perform()
                    #print self.reactions[i].name
                    break
            time.append([t]) 
            data.append([i.count for i in self.species])
            if n_steps % 500 == 0:
                print "Step: %d" % n_steps
        
        print "Simulation finished after %d steps" % n_steps
        data = np.asarray(data)
        time = np.asarray(time)
        total = np.hstack((time, data))
        #np.savetxt(filename, total, header = "Time " + str([i.name for i in self.species]))
        return total
        
def output_parser(filename):
    """Read in data for analysis.
    
    Given a data file generated by the simulate method of the Network class,
    read in data as numpy arrays that are amenable to further analysis or
    visualization.
    """    
    data = np.loadtxt(filename)
    pass